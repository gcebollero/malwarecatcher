from multiprocessing import Queue, Lock
import os
from tinydb import TinyDB, Query


class DB:
    # Locks dictionary for mutual exclusion access
    _locks = {}
    # Databases
    _dbs = {}

    # Database files folder
    folder = 'db_files'

    # VT rescan requests
    vt = Queue()
    vt_lock = None

    def __init__(self):
        # If 'db_files' folder does not exist, create
        if not os.path.exists(self.folder):
            os.makedirs(self.folder)
        # From 0x000 to 0xfff
        for i in range(0xfff+1):
            # generate lock for key 000 to fff
            key_i = str(hex(i))[2:].rjust(3, '0')
            db_i = '{}/{}.json'.format(self.folder, key_i)
            self._locks.update({key_i: Lock()})
            self._dbs.update({key_i: TinyDB(db_i)})
        self.vt_lock = Lock()

    def upsert_document(self, document: dict):
        if 'sha256' not in document:
            raise ValueError('Key \'sha256\' not present in document: {}'.format(document))
        index = document['sha256'][0:3]
        self._locks[index].acquire()
        self._dbs[index].upsert(document, Query().sha256 == document['sha256'])
        self._locks[index].release()

    def sequential_search(self, cond: Query) -> [dict]:
        results = []
        for key, db in self._dbs.items():
            self._locks[key].acquire()
            for document in db.search(cond):
                results.append(document)
            self._locks[key].release()
        return results

    def get_types_by_index(self, indexes: [str]):
        result = []
        for index in indexes:
            self._locks[index].acquire()
            result.append(self._dbs[index].search(Query().type_short.exists()))
            self._locks[index].release()
        return result

    def search(self, cond: Query) -> [dict]:
        return self.sequential_search(cond)

    def search_sha(self, sha256: str):
        index = sha256[0:3]
        self._locks[index].acquire()
        result = self._dbs[index].search(Query().sha256 == sha256)
        self._locks[index].release()
        return result

    def all(self) -> [dict]:
        results = []
        for key, db in self._dbs.items():
            self._locks[key].acquire()
            for document in db.all():
                results.append(document)
            self._locks[key].release()
        return results

    def count(self, cond: Query) -> int:
        count = 0
        for key, db in self._dbs.items():
            self._locks[key].acquire()
            count += db.count(cond)
            self._locks[key].release()
        return count

    def __len__(self):
        _len = 0
        for key, db in self._dbs.items():
            self._locks[key].acquire()
            _len += len(db)
            self._locks[key].release()
        return _len

    def request_sha256_for_vt_scan(self, sha256: str):
        print('before: {}'.format(self.vt))
        self.vt_lock.acquire()
        self.vt.put(sha256)
        self.vt_lock.release()
        print('after: {}'.format(self.vt))

    def obtain_pending_vt_scan(self) -> str:
        result = None
        print('previous: {}'.format(self.vt))
        if not self.vt.empty():
            self.vt_lock.acquire()
            result = self.vt.get()
            self.vt_lock.release()
        print('after: {}'.format(self.vt))
        return result
