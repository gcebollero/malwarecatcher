import logging
import time
from multiprocessing import Process, Queue, Manager
import Scheduler
import re

from flask import Flask, jsonify, render_template, request
from tinydb import Query
import Config
import Util
from DB import DB

db = DB()
# configuration
DEBUG = False
status = 'on'
action = None
vt_sha256_pending_scans = None

log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)
cache = Manager().dict()

# instantiate the app
app = Flask(__name__)
app.config.from_object(__name__)


logger = Util.configure_log(__name__)

# # # CONTROL ENDPOINTS # # #


@app.route('/action', methods=['GET'])
def get_action():
    global action
    tmp = {'action': action}
    action = None
    return tmp


@app.route('/status', methods=['GET'])
def get_status():
    return {'status': status}


@app.route('/stop', methods=['GET'])
def stop():
    global status
    status = 'off'
    return get_status()


@app.route('/start', methods=['GET'])
def start():
    global status, action
    status = 'on'
    action = 'restart'
    return get_status()


@app.route('/ping', methods=['GET'])
def ping_pong():
    return jsonify('pong!')

# # # API ENDPOINTS # # #


@app.route('/api/info/<sha256>', methods=['GET'])
def api_get_info(sha256):
    global db
    return jsonify(db.search(Query().sha256 == str(sha256)))


@app.route('/api/sha256/<partial>')
def api_get_hashes(partial):
    return jsonify(get_item_by_partial_hash(str(partial)))


@app.route('/api/tags', methods=['GET'])
def api_get_tags():
    return jsonify(get_tags())


@app.route('/api/types', methods=['GET'])
def api_get_types():
    return jsonify(get_types())


@app.route('/api/tag/<tag_name>', methods=['GET'])
def api_get_items_by_tag(tag_name):
    global db
    return jsonify(get_items_by_tag(tag_name))


@app.route('/api/type/<type_name>', methods=['GET'])
def api_get_items_by_type(type_name):
    return jsonify(get_items_by_type(type_name))


@app.route('/api/rescan/vt/<sha256>', methods=['GET'])
def api_rescan_vt(sha256: str):
    global action
    db.request_sha256_for_vt_scan(sha256=sha256)
    action = 'restart'
    return jsonify({'status': 200})


# # # VIEW ENDPOINTS # # #


@app.route('/hash', methods=['GET'])
def render_by_hash():
    return render_template('results.tmpl', items=(), filter='hash', filters=(), query="")


@app.route('/hash/<partial>', methods=['GET'])
def render_items_by_hash(partial: str):
    return render_template('results.tmpl', items=get_item_by_partial_hash(partial), filter='hash', filters=(), query=partial)


@app.route('/type', methods=['GET'])
def render_by_type():
    return render_template('results.tmpl', items=(), filter='type', filters=get_types(), query="")


@app.route('/type/<type_name>', methods=['GET'])
def render_items_by_type(type_name):
    return render_template('results.tmpl', items=get_items_by_type(str(type_name)), filter='type', filters=get_types(),
                           query=type_name)


@app.route('/tag/', methods=['GET'])
def render_by_tag():
    return render_template('results.tmpl', items=(), filter='tag', filters=get_tags(), query="")


@app.route('/tag/<tag_name>', methods=['GET'])
def render_items_by_tag(tag_name):
    global cache
    if request.path in cache and cache[request.path]['time'] > time.time() - 900000:  # cache per 15 min
        items = cache[request.path]['items']
        filters = cache[request.path]['filters']
    else:
        items = get_items_by_tag(str(tag_name))
        filters = get_tags()
        cache.update({request.path: {'items': items, 'filters': filters, 'time': time.time()}})
    return render_template('results.tmpl', items=items, filters=filters, filter='tag', query=tag_name)


@app.route('/sha256/<sha256>', methods=['GET'])
def render_item_info(sha256: str):
    item_info = get_item_info(sha256)[0]
    detections = {}
    for av in item_info['scanners']:
        for detection in av['anti_virus_results']:
            threat = detection['threat_found']
            if threat is not None:
                for tag in threat.split('.'):
                    detections[tag] = detections.get(tag, 0) + 1
    detections = dict(sorted(detections.items(), key=lambda x: x[1], reverse=True))
    detections = dict(list(detections.items())[0: 12])
    detections = dict(sorted(detections.items(), key=lambda x: x[1], reverse=False))
    return render_template('item.tmpl', item=item_info, detections=detections)


@app.route('/', methods=['GET'])
def index():
    global cache
    if request.path in cache and cache[request.path]['time'] > time.time() - 900000:  # cache per 15 min
        tags = cache[request.path]['tags']
        types = cache[request.path]['types']
        stats = cache[request.path]['stats']
    else:
        tags = get_tags(50)
        types = get_types()
        stats = get_stats()
        cache.update({request.path: {'tags': tags, 'types': types, 'stats': stats, 'time': time.time()}})
    return render_template('dashboard.tmpl', tags=tags, types=types, stats=stats)


@app.route('/settings', methods=['GET'])
def render_settings():
    return render_template('settings.tmpl', api_keys=Config.retrieve_api_key())


@app.route('/settings', methods=['POST'])
def set_settings():
    global action
    Config.save_api_key(request.form.to_dict())
    action = 'restart'
    return render_settings()

# # # FUNCTIONS # # #


def __generate_initial_cache():
    logger.info('Generating default cache')
    # Dashboard cache
    tags = get_tags(50)
    types = get_types()
    cache.update({'/': {'tags': tags, 'types': types, 'stats': get_stats(), 'time': time.time()}})
    # Top 10 tag cache
    filters = get_tags()
    for tag_name in list(tags.keys())[0:9]:
        items = get_items_by_tag(str(tag_name))
        cache.update({'/tag/{}'.format(tag_name): {'items': items, 'filters': filters, 'time': time.time()}})
    del tags
    # Top 10 file types cache
    for _type in list(types.keys())[0:9]:
        try:
           t = get_items_by_type(str(_type))
           cache.update({'/type/{}'.format(_type): {'type': t, 'time': time.time()}})
        except EOFError:
           logger.warning('Failed to generate /type/{} cache'.format(_type))
    logger.info('Cache generated successfully')


def get_item_by_partial_hash(sha256: str):
    return db.search(Query().sha256.matches('.*{}.*'.format(sha256), flags=re.IGNORECASE))


def get_tags(limit=0):
    global db
    # Tags to be returned
    tags = {}
    # For every item on DB with the tag field
    for item in db.all():
        # Mark as untagged all empty tags
        if 'tags' not in item or len(item['tags']) == 0:
            item['tags'] = ['untagged']
        # For every tag on item
        for tag in item['tags']:
            tags[tag] = tags.get(tag, 0) + 1
    if limit != 0 and len(tags) > limit:
        tags = dict(list(tags.items())[0: limit])
    tags = dict(sorted(tags.items(), key=lambda x: x[1], reverse=True))
    return tags


def get_types(limit=0):
    global db
    # Types to be returned
    types = {}
    # For every item on DB with the type field
    for item in db.all():
        # For every type on item
        if 'type_short' not in item or item['type_short'] is None:
            item['type_short'] = ['undefined']
        for _type in item['type_short']:
            types[_type] = types.get(_type, 0) + 1
    if limit != 0 and len(types) > limit:
        types = dict(list(types.items())[0: limit])
    types = dict(sorted(types.items(), key=lambda x: x[1], reverse=True))
    return types


def get_stats():
    indexed = db.count(Query().sha256.exists())
    stats = {
        'Pending': Util.count_samples() - indexed,
        'Indexed': indexed
    }
    return stats


def get_items_by_tag(tag_name):
    global db
    if tag_name == "untagged":
        return db.search(Query().tags == [])
    else:
        return db.search(Query().tags.any(str(tag_name)))


def get_items_by_type(type_name):
    global db
    if type_name == 'undefined':
        return db.search(Query().type_short == None)
    else:
        return db.search(Query().type_short.any(str(type_name)))


def get_item_info(sha256: str):
    vt_sha256_pending_scans.put(sha256)
    return db.search_sha(sha256)


def run():
    global vt_sha256_pending_scans
    vt_sha256_pending_scans = Queue()
    # Instantiate the cache generator process
    p_cache = Process(target=__generate_initial_cache)
    p_cache.start()
    # wait 15 seconds to generate dashboard's cache
    p_cache.join(15)
    # Launch scheduler process
    scheduler = Process(target=Scheduler.init, kwargs={"db": db, "vt_sha256_pending_scans": vt_sha256_pending_scans})
    scheduler.start()
    # run web server
    app.run()


if __name__ == "__main__":
    run()
