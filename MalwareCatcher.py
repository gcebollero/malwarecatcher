import logging
import time
from multiprocessing import Process, Queue
import Scheduler
import re

from flask import Flask, jsonify, render_template, request
from tinydb import Query
import Config
import Util
from DB import DB

db = DB()
# configuration
DEBUG = False
status = 'on'
action = None
vt_sha256_pending_scans = None

log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)
cache = {}

# instantiate the app
app = Flask(__name__)
app.config.from_object(__name__)


# # # CONTROL ENDPOINTS # # #


@app.route('/action', methods=['GET'])
def get_action():
    global action
    tmp = {'action': action}
    action = None
    return tmp


@app.route('/status', methods=['GET'])
def get_status():
    return {'status': status}


@app.route('/stop', methods=['GET'])
def stop():
    global status
    status = 'off'
    return get_status()


@app.route('/start', methods=['GET'])
def start():
    global status, action
    status = 'on'
    action = 'restart'
    return get_status()


@app.route('/ping', methods=['GET'])
def ping_pong():
    return jsonify('pong!')

# # # API ENDPOINTS # # #


@app.route('/api/info/<sha256>', methods=['GET'])
def api_get_info(sha256):
    global db
    return jsonify(db.search(Query().sha256 == str(sha256)))


@app.route('/api/sha256/<partial>')
def api_get_hashes(partial):
    return jsonify(get_item_by_partial_hash(str(partial)))


@app.route('/api/tags', methods=['GET'])
def api_get_tags():
    return jsonify(get_tags())


@app.route('/api/types', methods=['GET'])
def api_get_types():
    return jsonify(get_types())


@app.route('/api/tag/<tag_name>', methods=['GET'])
def api_get_items_by_tag(tag_name):
    global db
    return jsonify(get_items_by_tag(tag_name))


@app.route('/api/type/<type_name>', methods=['GET'])
def api_get_items_by_type(type_name):
    return jsonify(get_items_by_type(type_name))


@app.route('/api/rescan/vt/<sha256>', methods=['GET'])
def api_rescan_vt(sha256: str):
    global action
    db.request_sha256_for_vt_scan(sha256=sha256)
    action = 'restart'
    return jsonify({'status': 200})


# # # VIEW ENDPOINTS # # #


@app.route('/hash', methods=['GET'])
def render_by_hash():
    return render_template('results.tmpl', items=(), filter='hash', filters=(), query="")


@app.route('/hash/<partial>', methods=['GET'])
def render_items_by_hash(partial: str):
    return render_template('results.tmpl', items=get_item_by_partial_hash(partial), filter='hash', filters=(), query=partial)


@app.route('/type', methods=['GET'])
def render_by_type():
    return render_template('results.tmpl', items=(), filter='type', filters=get_types(), query="")


@app.route('/type/<type_name>', methods=['GET'])
def render_items_by_type(type_name):
    return render_template('results.tmpl', items=get_items_by_type(str(type_name)), filter='type', filters=get_types(),
                           query=type_name)


@app.route('/tag/', methods=['GET'])
def render_by_tag():
    return render_template('results.tmpl', items=(), filter='tag', filters=get_tags(), query="")


@app.route('/tag/<tag_name>', methods=['GET'])
def render_items_by_tag(tag_name):
    global cache
    if request.url in cache and cache[request.url]['time'] > time.time() - 900000: # cache per 15 min
        items = cache[request.url]['items']
        filters = cache[request.url]['filters']
    else:
        items = get_items_by_tag(str(tag_name))
        filters = get_tags()
        cache.update({request.url: {'items':items, 'filters': filters, 'time': time.time()}})
    return render_template('results.tmpl', items=items, filters=filters, filter='tag',
                           query=tag_name)


@app.route('/sha256/<sha256>', methods=['GET'])
def render_item_info(sha256: str):
    item_info = get_item_info(sha256)[0]
    detections = {}
    for av in item_info['scanners']:
        for detection in av['anti_virus_results']:
            threat = detection['threat_found']
            if threat is not None:
                for tag in threat.split('.'):
                    detections[tag] = detections.get(tag, 0) + 1
    detections = dict(sorted(detections.items(), key=lambda x: x[1], reverse=True))
    detections = dict(list(detections.items())[0: 12])
    detections = dict(sorted(detections.items(), key=lambda x: x[1], reverse=False))
    return render_template('item.tmpl', item=item_info, detections=detections)


@app.route('/', methods=['GET'])
def index():
    return render_template('dashboard.tmpl', tags=get_tags(50), types=get_types(), stats=get_stats())


@app.route('/settings', methods=['GET'])
def render_settings():
    return render_template('settings.tmpl', api_keys=Config.retrieve_api_key())


@app.route('/settings', methods=['POST'])
def set_settings():
    global action
    Config.save_api_key(request.form.to_dict())
    action = 'restart'
    return render_settings()

# # # FUNCTIONS # # #


def get_item_by_partial_hash(sha256: str):
    return db.search(Query().sha256.matches('.*{}.*'.format(sha256), flags=re.IGNORECASE))


def get_tags(limit=0):
    global db, cache
    if 'tags' in cache and cache['tags']['time'] > time.time() - 900000: # cache per 15 min
        return cache['tags']['tags']
    # Tags to be returned
    tags = {}
    # For every item on DB with the tag field
    for item in db.all():
        # Mark as untagged all empty tags
        if 'tags' not in item or len(item['tags']) == 0:
            item['tags'] = ['untagged']
        # For every tag on item
        for tag in item['tags']:
            tags[tag] = tags.get(tag, 0) + 1
    if limit != 0 and len(tags) > limit:
        tags = dict(list(tags.items())[0: limit])
    tags = dict(sorted(tags.items(), key=lambda x: x[1], reverse=True))
    cache.update({'tags': {'time': time.time(), 'tags':tags}})
    return tags


def get_types(limit=0):
    global db, cache
    if 'types' in cache and cache['types']['time'] > time.time() - 900000: # cache per 15 min
        return cache['types']['types']
    # Types to be returned
    types = {}
    # For every item on DB with the type field
    for item in db.all():
        # For every type on item
        if 'type_short' not in item or item['type_short'] is None:
            item['type_short'] = ['undefined']
        for _type in item['type_short']:
            types[_type] = types.get(_type, 0) + 1
    if limit != 0 and len(types) > limit:
        types = dict(list(types.items())[0: limit])
    types = dict(sorted(types.items(), key=lambda x: x[1], reverse=True))
    cache.update({'types': {'time': time.time(), 'types': types}})
    return types


def get_stats():
    indexed = db.count(Query().sha256.exists())
    stats = {
        'Pending': Util.count_samples() - indexed,
        'Indexed': indexed
    }
    return stats


def get_items_by_tag(tag_name):
    global db
    if tag_name == "untagged":
        return db.search(Query().tags == [])
    else:
        return db.search(Query().tags.any(str(tag_name)))


def get_items_by_type(type_name):
    global db
    if type_name == 'undefined':
        return db.search(Query().type_short == None)
    else:
        return db.search(Query().type_short.any(str(type_name)))


def get_item_info(sha256: str):
    vt_sha256_pending_scans.put(sha256)
    return db.search_sha(sha256)


def run():
    global vt_sha256_pending_scans
    vt_sha256_pending_scans = Queue()
    scheduler = Process(target=Scheduler.init, kwargs={"db": db, "vt_sha256_pending_scans": vt_sha256_pending_scans})
    scheduler.start()
    app.run()


if __name__ == "__main__":
    run()
